// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"polaris/ent/downloadclients"
	"polaris/ent/epidodes"
	"polaris/ent/history"
	"polaris/ent/indexers"
	"polaris/ent/predicate"
	"polaris/ent/series"
	"polaris/ent/settings"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDownloadClients = "DownloadClients"
	TypeEpidodes        = "Epidodes"
	TypeHistory         = "History"
	TypeIndexers        = "Indexers"
	TypeSeries          = "Series"
	TypeSettings        = "Settings"
)

// DownloadClientsMutation represents an operation that mutates the DownloadClients nodes in the graph.
type DownloadClientsMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	enable                     *bool
	name                       *string
	implementation             *string
	url                        *string
	user                       *string
	password                   *string
	settings                   *string
	priority                   *string
	remove_completed_downloads *bool
	remove_failed_downloads    *bool
	tags                       *string
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*DownloadClients, error)
	predicates                 []predicate.DownloadClients
}

var _ ent.Mutation = (*DownloadClientsMutation)(nil)

// downloadclientsOption allows management of the mutation configuration using functional options.
type downloadclientsOption func(*DownloadClientsMutation)

// newDownloadClientsMutation creates new mutation for the DownloadClients entity.
func newDownloadClientsMutation(c config, op Op, opts ...downloadclientsOption) *DownloadClientsMutation {
	m := &DownloadClientsMutation{
		config:        c,
		op:            op,
		typ:           TypeDownloadClients,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDownloadClientsID sets the ID field of the mutation.
func withDownloadClientsID(id int) downloadclientsOption {
	return func(m *DownloadClientsMutation) {
		var (
			err   error
			once  sync.Once
			value *DownloadClients
		)
		m.oldValue = func(ctx context.Context) (*DownloadClients, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DownloadClients.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDownloadClients sets the old DownloadClients of the mutation.
func withDownloadClients(node *DownloadClients) downloadclientsOption {
	return func(m *DownloadClientsMutation) {
		m.oldValue = func(context.Context) (*DownloadClients, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DownloadClientsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DownloadClientsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DownloadClientsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DownloadClientsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DownloadClients.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *DownloadClientsMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *DownloadClientsMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *DownloadClientsMutation) ResetEnable() {
	m.enable = nil
}

// SetName sets the "name" field.
func (m *DownloadClientsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DownloadClientsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DownloadClientsMutation) ResetName() {
	m.name = nil
}

// SetImplementation sets the "implementation" field.
func (m *DownloadClientsMutation) SetImplementation(s string) {
	m.implementation = &s
}

// Implementation returns the value of the "implementation" field in the mutation.
func (m *DownloadClientsMutation) Implementation() (r string, exists bool) {
	v := m.implementation
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementation returns the old "implementation" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldImplementation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementation: %w", err)
	}
	return oldValue.Implementation, nil
}

// ResetImplementation resets all changes to the "implementation" field.
func (m *DownloadClientsMutation) ResetImplementation() {
	m.implementation = nil
}

// SetURL sets the "url" field.
func (m *DownloadClientsMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DownloadClientsMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *DownloadClientsMutation) ResetURL() {
	m.url = nil
}

// SetUser sets the "user" field.
func (m *DownloadClientsMutation) SetUser(s string) {
	m.user = &s
}

// User returns the value of the "user" field in the mutation.
func (m *DownloadClientsMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old "user" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser resets all changes to the "user" field.
func (m *DownloadClientsMutation) ResetUser() {
	m.user = nil
}

// SetPassword sets the "password" field.
func (m *DownloadClientsMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *DownloadClientsMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *DownloadClientsMutation) ResetPassword() {
	m.password = nil
}

// SetSettings sets the "settings" field.
func (m *DownloadClientsMutation) SetSettings(s string) {
	m.settings = &s
}

// Settings returns the value of the "settings" field in the mutation.
func (m *DownloadClientsMutation) Settings() (r string, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldSettings(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *DownloadClientsMutation) ResetSettings() {
	m.settings = nil
}

// SetPriority sets the "priority" field.
func (m *DownloadClientsMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *DownloadClientsMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *DownloadClientsMutation) ResetPriority() {
	m.priority = nil
}

// SetRemoveCompletedDownloads sets the "remove_completed_downloads" field.
func (m *DownloadClientsMutation) SetRemoveCompletedDownloads(b bool) {
	m.remove_completed_downloads = &b
}

// RemoveCompletedDownloads returns the value of the "remove_completed_downloads" field in the mutation.
func (m *DownloadClientsMutation) RemoveCompletedDownloads() (r bool, exists bool) {
	v := m.remove_completed_downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveCompletedDownloads returns the old "remove_completed_downloads" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldRemoveCompletedDownloads(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveCompletedDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveCompletedDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveCompletedDownloads: %w", err)
	}
	return oldValue.RemoveCompletedDownloads, nil
}

// ResetRemoveCompletedDownloads resets all changes to the "remove_completed_downloads" field.
func (m *DownloadClientsMutation) ResetRemoveCompletedDownloads() {
	m.remove_completed_downloads = nil
}

// SetRemoveFailedDownloads sets the "remove_failed_downloads" field.
func (m *DownloadClientsMutation) SetRemoveFailedDownloads(b bool) {
	m.remove_failed_downloads = &b
}

// RemoveFailedDownloads returns the value of the "remove_failed_downloads" field in the mutation.
func (m *DownloadClientsMutation) RemoveFailedDownloads() (r bool, exists bool) {
	v := m.remove_failed_downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveFailedDownloads returns the old "remove_failed_downloads" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldRemoveFailedDownloads(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveFailedDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveFailedDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveFailedDownloads: %w", err)
	}
	return oldValue.RemoveFailedDownloads, nil
}

// ResetRemoveFailedDownloads resets all changes to the "remove_failed_downloads" field.
func (m *DownloadClientsMutation) ResetRemoveFailedDownloads() {
	m.remove_failed_downloads = nil
}

// SetTags sets the "tags" field.
func (m *DownloadClientsMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DownloadClientsMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *DownloadClientsMutation) ResetTags() {
	m.tags = nil
}

// Where appends a list predicates to the DownloadClientsMutation builder.
func (m *DownloadClientsMutation) Where(ps ...predicate.DownloadClients) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DownloadClientsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DownloadClientsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DownloadClients, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DownloadClientsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DownloadClientsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DownloadClients).
func (m *DownloadClientsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DownloadClientsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.enable != nil {
		fields = append(fields, downloadclients.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, downloadclients.FieldName)
	}
	if m.implementation != nil {
		fields = append(fields, downloadclients.FieldImplementation)
	}
	if m.url != nil {
		fields = append(fields, downloadclients.FieldURL)
	}
	if m.user != nil {
		fields = append(fields, downloadclients.FieldUser)
	}
	if m.password != nil {
		fields = append(fields, downloadclients.FieldPassword)
	}
	if m.settings != nil {
		fields = append(fields, downloadclients.FieldSettings)
	}
	if m.priority != nil {
		fields = append(fields, downloadclients.FieldPriority)
	}
	if m.remove_completed_downloads != nil {
		fields = append(fields, downloadclients.FieldRemoveCompletedDownloads)
	}
	if m.remove_failed_downloads != nil {
		fields = append(fields, downloadclients.FieldRemoveFailedDownloads)
	}
	if m.tags != nil {
		fields = append(fields, downloadclients.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DownloadClientsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case downloadclients.FieldEnable:
		return m.Enable()
	case downloadclients.FieldName:
		return m.Name()
	case downloadclients.FieldImplementation:
		return m.Implementation()
	case downloadclients.FieldURL:
		return m.URL()
	case downloadclients.FieldUser:
		return m.User()
	case downloadclients.FieldPassword:
		return m.Password()
	case downloadclients.FieldSettings:
		return m.Settings()
	case downloadclients.FieldPriority:
		return m.Priority()
	case downloadclients.FieldRemoveCompletedDownloads:
		return m.RemoveCompletedDownloads()
	case downloadclients.FieldRemoveFailedDownloads:
		return m.RemoveFailedDownloads()
	case downloadclients.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DownloadClientsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case downloadclients.FieldEnable:
		return m.OldEnable(ctx)
	case downloadclients.FieldName:
		return m.OldName(ctx)
	case downloadclients.FieldImplementation:
		return m.OldImplementation(ctx)
	case downloadclients.FieldURL:
		return m.OldURL(ctx)
	case downloadclients.FieldUser:
		return m.OldUser(ctx)
	case downloadclients.FieldPassword:
		return m.OldPassword(ctx)
	case downloadclients.FieldSettings:
		return m.OldSettings(ctx)
	case downloadclients.FieldPriority:
		return m.OldPriority(ctx)
	case downloadclients.FieldRemoveCompletedDownloads:
		return m.OldRemoveCompletedDownloads(ctx)
	case downloadclients.FieldRemoveFailedDownloads:
		return m.OldRemoveFailedDownloads(ctx)
	case downloadclients.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown DownloadClients field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadClientsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case downloadclients.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case downloadclients.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case downloadclients.FieldImplementation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementation(v)
		return nil
	case downloadclients.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case downloadclients.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case downloadclients.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case downloadclients.FieldSettings:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case downloadclients.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case downloadclients.FieldRemoveCompletedDownloads:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveCompletedDownloads(v)
		return nil
	case downloadclients.FieldRemoveFailedDownloads:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveFailedDownloads(v)
		return nil
	case downloadclients.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadClients field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DownloadClientsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DownloadClientsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadClientsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DownloadClients numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DownloadClientsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DownloadClientsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DownloadClientsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DownloadClients nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DownloadClientsMutation) ResetField(name string) error {
	switch name {
	case downloadclients.FieldEnable:
		m.ResetEnable()
		return nil
	case downloadclients.FieldName:
		m.ResetName()
		return nil
	case downloadclients.FieldImplementation:
		m.ResetImplementation()
		return nil
	case downloadclients.FieldURL:
		m.ResetURL()
		return nil
	case downloadclients.FieldUser:
		m.ResetUser()
		return nil
	case downloadclients.FieldPassword:
		m.ResetPassword()
		return nil
	case downloadclients.FieldSettings:
		m.ResetSettings()
		return nil
	case downloadclients.FieldPriority:
		m.ResetPriority()
		return nil
	case downloadclients.FieldRemoveCompletedDownloads:
		m.ResetRemoveCompletedDownloads()
		return nil
	case downloadclients.FieldRemoveFailedDownloads:
		m.ResetRemoveFailedDownloads()
		return nil
	case downloadclients.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown DownloadClients field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DownloadClientsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DownloadClientsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DownloadClientsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DownloadClientsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DownloadClientsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DownloadClientsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DownloadClientsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DownloadClients unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DownloadClientsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DownloadClients edge %s", name)
}

// EpidodesMutation represents an operation that mutates the Epidodes nodes in the graph.
type EpidodesMutation struct {
	config
	op                Op
	typ               string
	id                *int
	series_id         *int
	addseries_id      *int
	season_number     *int
	addseason_number  *int
	episode_number    *int
	addepisode_number *int
	title             *string
	overview          *string
	air_date          *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Epidodes, error)
	predicates        []predicate.Epidodes
}

var _ ent.Mutation = (*EpidodesMutation)(nil)

// epidodesOption allows management of the mutation configuration using functional options.
type epidodesOption func(*EpidodesMutation)

// newEpidodesMutation creates new mutation for the Epidodes entity.
func newEpidodesMutation(c config, op Op, opts ...epidodesOption) *EpidodesMutation {
	m := &EpidodesMutation{
		config:        c,
		op:            op,
		typ:           TypeEpidodes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpidodesID sets the ID field of the mutation.
func withEpidodesID(id int) epidodesOption {
	return func(m *EpidodesMutation) {
		var (
			err   error
			once  sync.Once
			value *Epidodes
		)
		m.oldValue = func(ctx context.Context) (*Epidodes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Epidodes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpidodes sets the old Epidodes of the mutation.
func withEpidodes(node *Epidodes) epidodesOption {
	return func(m *EpidodesMutation) {
		m.oldValue = func(context.Context) (*Epidodes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpidodesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpidodesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EpidodesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EpidodesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Epidodes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeriesID sets the "series_id" field.
func (m *EpidodesMutation) SetSeriesID(i int) {
	m.series_id = &i
	m.addseries_id = nil
}

// SeriesID returns the value of the "series_id" field in the mutation.
func (m *EpidodesMutation) SeriesID() (r int, exists bool) {
	v := m.series_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesID returns the old "series_id" field's value of the Epidodes entity.
// If the Epidodes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpidodesMutation) OldSeriesID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesID: %w", err)
	}
	return oldValue.SeriesID, nil
}

// AddSeriesID adds i to the "series_id" field.
func (m *EpidodesMutation) AddSeriesID(i int) {
	if m.addseries_id != nil {
		*m.addseries_id += i
	} else {
		m.addseries_id = &i
	}
}

// AddedSeriesID returns the value that was added to the "series_id" field in this mutation.
func (m *EpidodesMutation) AddedSeriesID() (r int, exists bool) {
	v := m.addseries_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeriesID resets all changes to the "series_id" field.
func (m *EpidodesMutation) ResetSeriesID() {
	m.series_id = nil
	m.addseries_id = nil
}

// SetSeasonNumber sets the "season_number" field.
func (m *EpidodesMutation) SetSeasonNumber(i int) {
	m.season_number = &i
	m.addseason_number = nil
}

// SeasonNumber returns the value of the "season_number" field in the mutation.
func (m *EpidodesMutation) SeasonNumber() (r int, exists bool) {
	v := m.season_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonNumber returns the old "season_number" field's value of the Epidodes entity.
// If the Epidodes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpidodesMutation) OldSeasonNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonNumber: %w", err)
	}
	return oldValue.SeasonNumber, nil
}

// AddSeasonNumber adds i to the "season_number" field.
func (m *EpidodesMutation) AddSeasonNumber(i int) {
	if m.addseason_number != nil {
		*m.addseason_number += i
	} else {
		m.addseason_number = &i
	}
}

// AddedSeasonNumber returns the value that was added to the "season_number" field in this mutation.
func (m *EpidodesMutation) AddedSeasonNumber() (r int, exists bool) {
	v := m.addseason_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeasonNumber resets all changes to the "season_number" field.
func (m *EpidodesMutation) ResetSeasonNumber() {
	m.season_number = nil
	m.addseason_number = nil
}

// SetEpisodeNumber sets the "episode_number" field.
func (m *EpidodesMutation) SetEpisodeNumber(i int) {
	m.episode_number = &i
	m.addepisode_number = nil
}

// EpisodeNumber returns the value of the "episode_number" field in the mutation.
func (m *EpidodesMutation) EpisodeNumber() (r int, exists bool) {
	v := m.episode_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeNumber returns the old "episode_number" field's value of the Epidodes entity.
// If the Epidodes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpidodesMutation) OldEpisodeNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeNumber: %w", err)
	}
	return oldValue.EpisodeNumber, nil
}

// AddEpisodeNumber adds i to the "episode_number" field.
func (m *EpidodesMutation) AddEpisodeNumber(i int) {
	if m.addepisode_number != nil {
		*m.addepisode_number += i
	} else {
		m.addepisode_number = &i
	}
}

// AddedEpisodeNumber returns the value that was added to the "episode_number" field in this mutation.
func (m *EpidodesMutation) AddedEpisodeNumber() (r int, exists bool) {
	v := m.addepisode_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeNumber resets all changes to the "episode_number" field.
func (m *EpidodesMutation) ResetEpisodeNumber() {
	m.episode_number = nil
	m.addepisode_number = nil
}

// SetTitle sets the "title" field.
func (m *EpidodesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EpidodesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Epidodes entity.
// If the Epidodes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpidodesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EpidodesMutation) ResetTitle() {
	m.title = nil
}

// SetOverview sets the "overview" field.
func (m *EpidodesMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *EpidodesMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the Epidodes entity.
// If the Epidodes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpidodesMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ResetOverview resets all changes to the "overview" field.
func (m *EpidodesMutation) ResetOverview() {
	m.overview = nil
}

// SetAirDate sets the "air_date" field.
func (m *EpidodesMutation) SetAirDate(s string) {
	m.air_date = &s
}

// AirDate returns the value of the "air_date" field in the mutation.
func (m *EpidodesMutation) AirDate() (r string, exists bool) {
	v := m.air_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAirDate returns the old "air_date" field's value of the Epidodes entity.
// If the Epidodes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpidodesMutation) OldAirDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAirDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAirDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAirDate: %w", err)
	}
	return oldValue.AirDate, nil
}

// ResetAirDate resets all changes to the "air_date" field.
func (m *EpidodesMutation) ResetAirDate() {
	m.air_date = nil
}

// Where appends a list predicates to the EpidodesMutation builder.
func (m *EpidodesMutation) Where(ps ...predicate.Epidodes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EpidodesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EpidodesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Epidodes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EpidodesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EpidodesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Epidodes).
func (m *EpidodesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EpidodesMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.series_id != nil {
		fields = append(fields, epidodes.FieldSeriesID)
	}
	if m.season_number != nil {
		fields = append(fields, epidodes.FieldSeasonNumber)
	}
	if m.episode_number != nil {
		fields = append(fields, epidodes.FieldEpisodeNumber)
	}
	if m.title != nil {
		fields = append(fields, epidodes.FieldTitle)
	}
	if m.overview != nil {
		fields = append(fields, epidodes.FieldOverview)
	}
	if m.air_date != nil {
		fields = append(fields, epidodes.FieldAirDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EpidodesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case epidodes.FieldSeriesID:
		return m.SeriesID()
	case epidodes.FieldSeasonNumber:
		return m.SeasonNumber()
	case epidodes.FieldEpisodeNumber:
		return m.EpisodeNumber()
	case epidodes.FieldTitle:
		return m.Title()
	case epidodes.FieldOverview:
		return m.Overview()
	case epidodes.FieldAirDate:
		return m.AirDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EpidodesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case epidodes.FieldSeriesID:
		return m.OldSeriesID(ctx)
	case epidodes.FieldSeasonNumber:
		return m.OldSeasonNumber(ctx)
	case epidodes.FieldEpisodeNumber:
		return m.OldEpisodeNumber(ctx)
	case epidodes.FieldTitle:
		return m.OldTitle(ctx)
	case epidodes.FieldOverview:
		return m.OldOverview(ctx)
	case epidodes.FieldAirDate:
		return m.OldAirDate(ctx)
	}
	return nil, fmt.Errorf("unknown Epidodes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpidodesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case epidodes.FieldSeriesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesID(v)
		return nil
	case epidodes.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonNumber(v)
		return nil
	case epidodes.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeNumber(v)
		return nil
	case epidodes.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case epidodes.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case epidodes.FieldAirDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAirDate(v)
		return nil
	}
	return fmt.Errorf("unknown Epidodes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EpidodesMutation) AddedFields() []string {
	var fields []string
	if m.addseries_id != nil {
		fields = append(fields, epidodes.FieldSeriesID)
	}
	if m.addseason_number != nil {
		fields = append(fields, epidodes.FieldSeasonNumber)
	}
	if m.addepisode_number != nil {
		fields = append(fields, epidodes.FieldEpisodeNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EpidodesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case epidodes.FieldSeriesID:
		return m.AddedSeriesID()
	case epidodes.FieldSeasonNumber:
		return m.AddedSeasonNumber()
	case epidodes.FieldEpisodeNumber:
		return m.AddedEpisodeNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpidodesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case epidodes.FieldSeriesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeriesID(v)
		return nil
	case epidodes.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeasonNumber(v)
		return nil
	case epidodes.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Epidodes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EpidodesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EpidodesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpidodesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Epidodes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EpidodesMutation) ResetField(name string) error {
	switch name {
	case epidodes.FieldSeriesID:
		m.ResetSeriesID()
		return nil
	case epidodes.FieldSeasonNumber:
		m.ResetSeasonNumber()
		return nil
	case epidodes.FieldEpisodeNumber:
		m.ResetEpisodeNumber()
		return nil
	case epidodes.FieldTitle:
		m.ResetTitle()
		return nil
	case epidodes.FieldOverview:
		m.ResetOverview()
		return nil
	case epidodes.FieldAirDate:
		m.ResetAirDate()
		return nil
	}
	return fmt.Errorf("unknown Epidodes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EpidodesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EpidodesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EpidodesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EpidodesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EpidodesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EpidodesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EpidodesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Epidodes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EpidodesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Epidodes edge %s", name)
}

// HistoryMutation represents an operation that mutates the History nodes in the graph.
type HistoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	series_id     *int
	addseries_id  *int
	episode_id    *int
	addepisode_id *int
	source_title  *string
	date          *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*History, error)
	predicates    []predicate.History
}

var _ ent.Mutation = (*HistoryMutation)(nil)

// historyOption allows management of the mutation configuration using functional options.
type historyOption func(*HistoryMutation)

// newHistoryMutation creates new mutation for the History entity.
func newHistoryMutation(c config, op Op, opts ...historyOption) *HistoryMutation {
	m := &HistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistoryID sets the ID field of the mutation.
func withHistoryID(id int) historyOption {
	return func(m *HistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *History
		)
		m.oldValue = func(ctx context.Context) (*History, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().History.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistory sets the old History of the mutation.
func withHistory(node *History) historyOption {
	return func(m *HistoryMutation) {
		m.oldValue = func(context.Context) (*History, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().History.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeriesID sets the "series_id" field.
func (m *HistoryMutation) SetSeriesID(i int) {
	m.series_id = &i
	m.addseries_id = nil
}

// SeriesID returns the value of the "series_id" field in the mutation.
func (m *HistoryMutation) SeriesID() (r int, exists bool) {
	v := m.series_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesID returns the old "series_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldSeriesID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesID: %w", err)
	}
	return oldValue.SeriesID, nil
}

// AddSeriesID adds i to the "series_id" field.
func (m *HistoryMutation) AddSeriesID(i int) {
	if m.addseries_id != nil {
		*m.addseries_id += i
	} else {
		m.addseries_id = &i
	}
}

// AddedSeriesID returns the value that was added to the "series_id" field in this mutation.
func (m *HistoryMutation) AddedSeriesID() (r int, exists bool) {
	v := m.addseries_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeriesID resets all changes to the "series_id" field.
func (m *HistoryMutation) ResetSeriesID() {
	m.series_id = nil
	m.addseries_id = nil
}

// SetEpisodeID sets the "episode_id" field.
func (m *HistoryMutation) SetEpisodeID(i int) {
	m.episode_id = &i
	m.addepisode_id = nil
}

// EpisodeID returns the value of the "episode_id" field in the mutation.
func (m *HistoryMutation) EpisodeID() (r int, exists bool) {
	v := m.episode_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeID returns the old "episode_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldEpisodeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeID: %w", err)
	}
	return oldValue.EpisodeID, nil
}

// AddEpisodeID adds i to the "episode_id" field.
func (m *HistoryMutation) AddEpisodeID(i int) {
	if m.addepisode_id != nil {
		*m.addepisode_id += i
	} else {
		m.addepisode_id = &i
	}
}

// AddedEpisodeID returns the value that was added to the "episode_id" field in this mutation.
func (m *HistoryMutation) AddedEpisodeID() (r int, exists bool) {
	v := m.addepisode_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeID resets all changes to the "episode_id" field.
func (m *HistoryMutation) ResetEpisodeID() {
	m.episode_id = nil
	m.addepisode_id = nil
}

// SetSourceTitle sets the "source_title" field.
func (m *HistoryMutation) SetSourceTitle(s string) {
	m.source_title = &s
}

// SourceTitle returns the value of the "source_title" field in the mutation.
func (m *HistoryMutation) SourceTitle() (r string, exists bool) {
	v := m.source_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceTitle returns the old "source_title" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldSourceTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceTitle: %w", err)
	}
	return oldValue.SourceTitle, nil
}

// ResetSourceTitle resets all changes to the "source_title" field.
func (m *HistoryMutation) ResetSourceTitle() {
	m.source_title = nil
}

// SetDate sets the "date" field.
func (m *HistoryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *HistoryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *HistoryMutation) ResetDate() {
	m.date = nil
}

// Where appends a list predicates to the HistoryMutation builder.
func (m *HistoryMutation) Where(ps ...predicate.History) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.History, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (History).
func (m *HistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HistoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.series_id != nil {
		fields = append(fields, history.FieldSeriesID)
	}
	if m.episode_id != nil {
		fields = append(fields, history.FieldEpisodeID)
	}
	if m.source_title != nil {
		fields = append(fields, history.FieldSourceTitle)
	}
	if m.date != nil {
		fields = append(fields, history.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case history.FieldSeriesID:
		return m.SeriesID()
	case history.FieldEpisodeID:
		return m.EpisodeID()
	case history.FieldSourceTitle:
		return m.SourceTitle()
	case history.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case history.FieldSeriesID:
		return m.OldSeriesID(ctx)
	case history.FieldEpisodeID:
		return m.OldEpisodeID(ctx)
	case history.FieldSourceTitle:
		return m.OldSourceTitle(ctx)
	case history.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown History field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case history.FieldSeriesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesID(v)
		return nil
	case history.FieldEpisodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeID(v)
		return nil
	case history.FieldSourceTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceTitle(v)
		return nil
	case history.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HistoryMutation) AddedFields() []string {
	var fields []string
	if m.addseries_id != nil {
		fields = append(fields, history.FieldSeriesID)
	}
	if m.addepisode_id != nil {
		fields = append(fields, history.FieldEpisodeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case history.FieldSeriesID:
		return m.AddedSeriesID()
	case history.FieldEpisodeID:
		return m.AddedEpisodeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case history.FieldSeriesID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeriesID(v)
		return nil
	case history.FieldEpisodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeID(v)
		return nil
	}
	return fmt.Errorf("unknown History numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown History nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HistoryMutation) ResetField(name string) error {
	switch name {
	case history.FieldSeriesID:
		m.ResetSeriesID()
		return nil
	case history.FieldEpisodeID:
		m.ResetEpisodeID()
		return nil
	case history.FieldSourceTitle:
		m.ResetSourceTitle()
		return nil
	case history.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown History unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown History edge %s", name)
}

// IndexersMutation represents an operation that mutates the Indexers nodes in the graph.
type IndexersMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	implementation *string
	settings       *string
	enable_rss     *bool
	priority       *int
	addpriority    *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Indexers, error)
	predicates     []predicate.Indexers
}

var _ ent.Mutation = (*IndexersMutation)(nil)

// indexersOption allows management of the mutation configuration using functional options.
type indexersOption func(*IndexersMutation)

// newIndexersMutation creates new mutation for the Indexers entity.
func newIndexersMutation(c config, op Op, opts ...indexersOption) *IndexersMutation {
	m := &IndexersMutation{
		config:        c,
		op:            op,
		typ:           TypeIndexers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndexersID sets the ID field of the mutation.
func withIndexersID(id int) indexersOption {
	return func(m *IndexersMutation) {
		var (
			err   error
			once  sync.Once
			value *Indexers
		)
		m.oldValue = func(ctx context.Context) (*Indexers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Indexers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndexers sets the old Indexers of the mutation.
func withIndexers(node *Indexers) indexersOption {
	return func(m *IndexersMutation) {
		m.oldValue = func(context.Context) (*Indexers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndexersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndexersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndexersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndexersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Indexers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IndexersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IndexersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IndexersMutation) ResetName() {
	m.name = nil
}

// SetImplementation sets the "implementation" field.
func (m *IndexersMutation) SetImplementation(s string) {
	m.implementation = &s
}

// Implementation returns the value of the "implementation" field in the mutation.
func (m *IndexersMutation) Implementation() (r string, exists bool) {
	v := m.implementation
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementation returns the old "implementation" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldImplementation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementation: %w", err)
	}
	return oldValue.Implementation, nil
}

// ResetImplementation resets all changes to the "implementation" field.
func (m *IndexersMutation) ResetImplementation() {
	m.implementation = nil
}

// SetSettings sets the "settings" field.
func (m *IndexersMutation) SetSettings(s string) {
	m.settings = &s
}

// Settings returns the value of the "settings" field in the mutation.
func (m *IndexersMutation) Settings() (r string, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldSettings(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *IndexersMutation) ResetSettings() {
	m.settings = nil
}

// SetEnableRss sets the "enable_rss" field.
func (m *IndexersMutation) SetEnableRss(b bool) {
	m.enable_rss = &b
}

// EnableRss returns the value of the "enable_rss" field in the mutation.
func (m *IndexersMutation) EnableRss() (r bool, exists bool) {
	v := m.enable_rss
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableRss returns the old "enable_rss" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldEnableRss(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableRss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableRss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableRss: %w", err)
	}
	return oldValue.EnableRss, nil
}

// ResetEnableRss resets all changes to the "enable_rss" field.
func (m *IndexersMutation) ResetEnableRss() {
	m.enable_rss = nil
}

// SetPriority sets the "priority" field.
func (m *IndexersMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IndexersMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *IndexersMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *IndexersMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *IndexersMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// Where appends a list predicates to the IndexersMutation builder.
func (m *IndexersMutation) Where(ps ...predicate.Indexers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IndexersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IndexersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Indexers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IndexersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IndexersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Indexers).
func (m *IndexersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndexersMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, indexers.FieldName)
	}
	if m.implementation != nil {
		fields = append(fields, indexers.FieldImplementation)
	}
	if m.settings != nil {
		fields = append(fields, indexers.FieldSettings)
	}
	if m.enable_rss != nil {
		fields = append(fields, indexers.FieldEnableRss)
	}
	if m.priority != nil {
		fields = append(fields, indexers.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndexersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case indexers.FieldName:
		return m.Name()
	case indexers.FieldImplementation:
		return m.Implementation()
	case indexers.FieldSettings:
		return m.Settings()
	case indexers.FieldEnableRss:
		return m.EnableRss()
	case indexers.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndexersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case indexers.FieldName:
		return m.OldName(ctx)
	case indexers.FieldImplementation:
		return m.OldImplementation(ctx)
	case indexers.FieldSettings:
		return m.OldSettings(ctx)
	case indexers.FieldEnableRss:
		return m.OldEnableRss(ctx)
	case indexers.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Indexers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndexersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case indexers.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case indexers.FieldImplementation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementation(v)
		return nil
	case indexers.FieldSettings:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case indexers.FieldEnableRss:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableRss(v)
		return nil
	case indexers.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Indexers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndexersMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, indexers.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndexersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case indexers.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndexersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case indexers.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Indexers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndexersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndexersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndexersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Indexers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndexersMutation) ResetField(name string) error {
	switch name {
	case indexers.FieldName:
		m.ResetName()
		return nil
	case indexers.FieldImplementation:
		m.ResetImplementation()
		return nil
	case indexers.FieldSettings:
		m.ResetSettings()
		return nil
	case indexers.FieldEnableRss:
		m.ResetEnableRss()
		return nil
	case indexers.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Indexers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndexersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndexersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndexersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndexersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndexersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndexersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndexersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Indexers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndexersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Indexers edge %s", name)
}

// SeriesMutation represents an operation that mutates the Series nodes in the graph.
type SeriesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	tmdb_id       *int
	addtmdb_id    *int
	imdb_id       *string
	title         *string
	original_name *string
	overview      *string
	_path         *string
	poster_path   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Series, error)
	predicates    []predicate.Series
}

var _ ent.Mutation = (*SeriesMutation)(nil)

// seriesOption allows management of the mutation configuration using functional options.
type seriesOption func(*SeriesMutation)

// newSeriesMutation creates new mutation for the Series entity.
func newSeriesMutation(c config, op Op, opts ...seriesOption) *SeriesMutation {
	m := &SeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeriesID sets the ID field of the mutation.
func withSeriesID(id int) seriesOption {
	return func(m *SeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *Series
		)
		m.oldValue = func(ctx context.Context) (*Series, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Series.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeries sets the old Series of the mutation.
func withSeries(node *Series) seriesOption {
	return func(m *SeriesMutation) {
		m.oldValue = func(context.Context) (*Series, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeriesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeriesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Series.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTmdbID sets the "tmdb_id" field.
func (m *SeriesMutation) SetTmdbID(i int) {
	m.tmdb_id = &i
	m.addtmdb_id = nil
}

// TmdbID returns the value of the "tmdb_id" field in the mutation.
func (m *SeriesMutation) TmdbID() (r int, exists bool) {
	v := m.tmdb_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTmdbID returns the old "tmdb_id" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldTmdbID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTmdbID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTmdbID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTmdbID: %w", err)
	}
	return oldValue.TmdbID, nil
}

// AddTmdbID adds i to the "tmdb_id" field.
func (m *SeriesMutation) AddTmdbID(i int) {
	if m.addtmdb_id != nil {
		*m.addtmdb_id += i
	} else {
		m.addtmdb_id = &i
	}
}

// AddedTmdbID returns the value that was added to the "tmdb_id" field in this mutation.
func (m *SeriesMutation) AddedTmdbID() (r int, exists bool) {
	v := m.addtmdb_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTmdbID resets all changes to the "tmdb_id" field.
func (m *SeriesMutation) ResetTmdbID() {
	m.tmdb_id = nil
	m.addtmdb_id = nil
}

// SetImdbID sets the "imdb_id" field.
func (m *SeriesMutation) SetImdbID(s string) {
	m.imdb_id = &s
}

// ImdbID returns the value of the "imdb_id" field in the mutation.
func (m *SeriesMutation) ImdbID() (r string, exists bool) {
	v := m.imdb_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImdbID returns the old "imdb_id" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldImdbID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImdbID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImdbID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImdbID: %w", err)
	}
	return oldValue.ImdbID, nil
}

// ClearImdbID clears the value of the "imdb_id" field.
func (m *SeriesMutation) ClearImdbID() {
	m.imdb_id = nil
	m.clearedFields[series.FieldImdbID] = struct{}{}
}

// ImdbIDCleared returns if the "imdb_id" field was cleared in this mutation.
func (m *SeriesMutation) ImdbIDCleared() bool {
	_, ok := m.clearedFields[series.FieldImdbID]
	return ok
}

// ResetImdbID resets all changes to the "imdb_id" field.
func (m *SeriesMutation) ResetImdbID() {
	m.imdb_id = nil
	delete(m.clearedFields, series.FieldImdbID)
}

// SetTitle sets the "title" field.
func (m *SeriesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SeriesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SeriesMutation) ResetTitle() {
	m.title = nil
}

// SetOriginalName sets the "original_name" field.
func (m *SeriesMutation) SetOriginalName(s string) {
	m.original_name = &s
}

// OriginalName returns the value of the "original_name" field in the mutation.
func (m *SeriesMutation) OriginalName() (r string, exists bool) {
	v := m.original_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalName returns the old "original_name" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldOriginalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalName: %w", err)
	}
	return oldValue.OriginalName, nil
}

// ResetOriginalName resets all changes to the "original_name" field.
func (m *SeriesMutation) ResetOriginalName() {
	m.original_name = nil
}

// SetOverview sets the "overview" field.
func (m *SeriesMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *SeriesMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ResetOverview resets all changes to the "overview" field.
func (m *SeriesMutation) ResetOverview() {
	m.overview = nil
}

// SetPath sets the "path" field.
func (m *SeriesMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *SeriesMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *SeriesMutation) ResetPath() {
	m._path = nil
}

// SetPosterPath sets the "poster_path" field.
func (m *SeriesMutation) SetPosterPath(s string) {
	m.poster_path = &s
}

// PosterPath returns the value of the "poster_path" field in the mutation.
func (m *SeriesMutation) PosterPath() (r string, exists bool) {
	v := m.poster_path
	if v == nil {
		return
	}
	return *v, true
}

// OldPosterPath returns the old "poster_path" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldPosterPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosterPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosterPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosterPath: %w", err)
	}
	return oldValue.PosterPath, nil
}

// ClearPosterPath clears the value of the "poster_path" field.
func (m *SeriesMutation) ClearPosterPath() {
	m.poster_path = nil
	m.clearedFields[series.FieldPosterPath] = struct{}{}
}

// PosterPathCleared returns if the "poster_path" field was cleared in this mutation.
func (m *SeriesMutation) PosterPathCleared() bool {
	_, ok := m.clearedFields[series.FieldPosterPath]
	return ok
}

// ResetPosterPath resets all changes to the "poster_path" field.
func (m *SeriesMutation) ResetPosterPath() {
	m.poster_path = nil
	delete(m.clearedFields, series.FieldPosterPath)
}

// SetCreatedAt sets the "created_at" field.
func (m *SeriesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SeriesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SeriesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the SeriesMutation builder.
func (m *SeriesMutation) Where(ps ...predicate.Series) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Series, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Series).
func (m *SeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeriesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tmdb_id != nil {
		fields = append(fields, series.FieldTmdbID)
	}
	if m.imdb_id != nil {
		fields = append(fields, series.FieldImdbID)
	}
	if m.title != nil {
		fields = append(fields, series.FieldTitle)
	}
	if m.original_name != nil {
		fields = append(fields, series.FieldOriginalName)
	}
	if m.overview != nil {
		fields = append(fields, series.FieldOverview)
	}
	if m._path != nil {
		fields = append(fields, series.FieldPath)
	}
	if m.poster_path != nil {
		fields = append(fields, series.FieldPosterPath)
	}
	if m.created_at != nil {
		fields = append(fields, series.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case series.FieldTmdbID:
		return m.TmdbID()
	case series.FieldImdbID:
		return m.ImdbID()
	case series.FieldTitle:
		return m.Title()
	case series.FieldOriginalName:
		return m.OriginalName()
	case series.FieldOverview:
		return m.Overview()
	case series.FieldPath:
		return m.Path()
	case series.FieldPosterPath:
		return m.PosterPath()
	case series.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case series.FieldTmdbID:
		return m.OldTmdbID(ctx)
	case series.FieldImdbID:
		return m.OldImdbID(ctx)
	case series.FieldTitle:
		return m.OldTitle(ctx)
	case series.FieldOriginalName:
		return m.OldOriginalName(ctx)
	case series.FieldOverview:
		return m.OldOverview(ctx)
	case series.FieldPath:
		return m.OldPath(ctx)
	case series.FieldPosterPath:
		return m.OldPosterPath(ctx)
	case series.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Series field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case series.FieldTmdbID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTmdbID(v)
		return nil
	case series.FieldImdbID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImdbID(v)
		return nil
	case series.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case series.FieldOriginalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalName(v)
		return nil
	case series.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case series.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case series.FieldPosterPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosterPath(v)
		return nil
	case series.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeriesMutation) AddedFields() []string {
	var fields []string
	if m.addtmdb_id != nil {
		fields = append(fields, series.FieldTmdbID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case series.FieldTmdbID:
		return m.AddedTmdbID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case series.FieldTmdbID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTmdbID(v)
		return nil
	}
	return fmt.Errorf("unknown Series numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(series.FieldImdbID) {
		fields = append(fields, series.FieldImdbID)
	}
	if m.FieldCleared(series.FieldPosterPath) {
		fields = append(fields, series.FieldPosterPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeriesMutation) ClearField(name string) error {
	switch name {
	case series.FieldImdbID:
		m.ClearImdbID()
		return nil
	case series.FieldPosterPath:
		m.ClearPosterPath()
		return nil
	}
	return fmt.Errorf("unknown Series nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeriesMutation) ResetField(name string) error {
	switch name {
	case series.FieldTmdbID:
		m.ResetTmdbID()
		return nil
	case series.FieldImdbID:
		m.ResetImdbID()
		return nil
	case series.FieldTitle:
		m.ResetTitle()
		return nil
	case series.FieldOriginalName:
		m.ResetOriginalName()
		return nil
	case series.FieldOverview:
		m.ResetOverview()
		return nil
	case series.FieldPath:
		m.ResetPath()
		return nil
	case series.FieldPosterPath:
		m.ResetPosterPath()
		return nil
	case series.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeriesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeriesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeriesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeriesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Series unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeriesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Series edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Settings, error)
	predicates    []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SettingsMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingsMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingsMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingsMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingsMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingsMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.key != nil {
		fields = append(fields, settings.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, settings.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldKey:
		return m.Key()
	case settings.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldKey:
		return m.OldKey(ctx)
	case settings.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case settings.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldKey:
		m.ResetKey()
		return nil
	case settings.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Settings edge %s", name)
}
